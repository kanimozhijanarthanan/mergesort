package MergeSortAlgorithm;

import java.util.Random;

public class IterativeMergeSort {

    public static Random randomGenerator = new Random();
    public static int numberOfTrials = 50;
    public static int insertionSortThreshold = 15; // threshold for insertion sort

    public static void main(String[] args) {
        System.out.println(insertionSortThreshold);
        int[] sizes = {16_000_000, 32_000_000, 64_000_000, 96_000_000, 128_000_000}; // Values of n to test
        for (int size : sizes) {
            try {
                runTest(size);
            } catch (OutOfMemoryError e) {
                System.out.println("OutOfMemoryError for n = " + size);
                break;
            }
        }
    }

    public static void generateWorstCaseArray(int[] array, int start, int size) {
        if (size == 1) {
            array[start] = 1;
            return;
        }
        int halfSize = size / 2;
        generateWorstCaseArray(array, start, halfSize);
        generateWorstCaseArray(array, start + halfSize, (size % 2 == 0 ? halfSize : halfSize + 1));
        for (int i = start; i < start + halfSize; i++) {
            array[i] *= 2;
        }
        for (int i = start + halfSize; i < start + size; i++) {
            array[i] = array[i] * 2 - 1;
        }
    }

    public static void runTest(int n) {
        System.out.println("Running tests for n = " + n);
        Timer timer = new Timer();
        long totalDuration = 0;

        for (int i = 0; i < numberOfTrials; i++) {
            int[] array = new int[n];
            int[] wcInput = new int[n];
            generateWorstCaseArray(wcInput, 0, wcInput.length);
            initializeArray(array, wcInput);

            timer.start();
            mergeSort(array);
            timer.end();
            totalDuration += timer.duration();
            System.out.println("Iteration " + i);
        }

        long averageDuration = totalDuration / numberOfTrials;
        System.out.println("Average time for n = " + n + ": " + averageDuration + " msec.");
        System.out.println("Memory used: " + (timer.memory() / 1048576) + " MB");
    }

    // Algorithm Starts here

    public static void mergeSort(int[] array) {
        int n = array.length;
        int[] tempArray = new int[n];
        System.arraycopy(array, 0, tempArray, 0, n);

        // Apply insertion sort on small chunks
        for (int i = 0; i < n; i += insertionSortThreshold) {
            int right = Math.min(i + insertionSortThreshold - 1, n - 1);
            insertionSort(array, i, right);
        }

        // Merge sorted chunks
        for (int size = insertionSortThreshold; size < n; size *= 2) {
            for (int i = 0; i < n; i += 2 * size) {
                int mid = Math.min(i + size - 1, n - 1);
                int right = Math.min(i + 2 * size - 1, n - 1);
                merge(tempArray, array, i, mid, right);
            }
            int[] temp = array;
            array = tempArray;
            tempArray = temp;
        }

        if (array != tempArray) {
            System.arraycopy(array, 0, tempArray, 0, n);
        }
    }

    private static void insertionSort(int[] array, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int key = array[i];
            int j = i - 1;
            while (j >= left && array[j] > key) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }

    private static void merge(int[] sourceArray, int[] targetArray, int left, int mid, int right) {
        int i = left, j = mid + 1, k = left;

        while (i <= mid && j <= right) {
            if (sourceArray[i] <= sourceArray[j]) {
                targetArray[k++] = sourceArray[i++];
            } else {
                targetArray[k++] = sourceArray[j++];
            }
        }

        while (i <= mid) {
            targetArray[k++] = sourceArray[i++];
        }

        while (j <= right) {
            targetArray[k++] = sourceArray[j++];
        }
    }

    // Algorithm Ends here

    // Helper Methods
    public static void initializeArray(int[] array, int[] sourceArray) {
        System.arraycopy(sourceArray, 0, array, 0, array.length);
    }

    public static class Timer {
        long startTime, endTime, elapsedTime, memAvailable, memUsed;
        boolean ready;

        public Timer() {
            startTime = System.currentTimeMillis();
            ready = false;
        }

        public void start() {
            startTime = System.currentTimeMillis();
            ready = false;
        }

        public Timer end() {
            endTime = System.currentTimeMillis();
            elapsedTime = endTime - startTime;
            memAvailable = Runtime.getRuntime().totalMemory();
            memUsed = memAvailable - Runtime.getRuntime().freeMemory();
            ready = true;
            return this;
        }

        public long duration() {
            if (!ready) {
                end();
            }
            return elapsedTime;
        }

        public long memory() {
            if (!ready) {
                end();
            }
            return memUsed;
        }
    }
}




